/**
 * Chiron PWA Service Worker
 * 
 * Cache-first, update-in-background strategy
 * Provides instant page loads on repeat visits while ensuring content freshness
 * 
 * Generated by Chiron Cache Manager
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API
 */

// ============================================================================
// CACHE CONFIGURATION
// ============================================================================

/**
 * Cache version - changes on every build
 * When this changes, old caches are automatically cleaned up
 */
const CACHE_VERSION = 'ccf2b728';

/**
 * Cache names with version
 */
const CACHE_NAMES = {
  CRITICAL: `chiron-critical-${CACHE_VERSION}`,
  FONTS: `chiron-fonts-${CACHE_VERSION}`,
  IMAGES: `chiron-images-${CACHE_VERSION}`,
  STATIC: `chiron-static-${CACHE_VERSION}`
};

/**
 * All cache names for cleanup
 */
const ALL_CACHES = Object.values(CACHE_NAMES);

/**
 * Critical assets - precached on install (HTML, CSS, fonts)
 * These provide instant page loads and eliminate FOUC
 */
const CRITICAL_ASSETS = [
  '/',
  '/404.html',
  '/api-reference.html',
  '/blog/author/marco-rossi.html',
  '/blog/building-modern-documentation.html',
  '/blog/category/tutorials.html',
  '/blog/first-post.html',
  '/blog/index.html',
  '/blog/second-post.html',
  '/blog/tag/javascript.html',
  '/blog/third-post.html',
  '/blog/welcome-to-chiron.html',
  '/buttons-showcase.html',
  '/custom-template-test.html',
  '/dashboard-demo.html',
  '/data-island-docs.html',
  '/embeds-demo.html',
  '/en/api-reference.html',
  '/en/custom-template-test.html',
  '/en/dashboard-demo.html',
  '/en/embeds-demo.html',
  '/en/external-scripts-demo.html',
  '/en/forms-demo.html',
  '/en/grid-demo.html',
  '/en/index.html',
  '/en/landing-demo.html',
  '/en/manage-cookies.html',
  '/en/privacy-policy.html',
  '/en/react-demo.html',
  '/en/shortcodes-showcase.html',
  '/en/showcase.html',
  '/en/slideshow-demo.html',
  '/en/tabs-demo.html',
  '/en/terms-of-service.html',
  '/en/test-shortcodes.html',
  '/en/toc-depth-test.html',
  '/external-scripts-demo.html',
  '/forms-demo.html',
  '/grid-demo.html',
  '/index.html',
  '/it/api-reference.html',
  '/it/blog/author/marco-rossi.html',
  '/it/blog/building-modern-documentation.html',
  '/it/blog/category/tutorials.html',
  '/it/blog/first-post.html',
  '/it/blog/index.html',
  '/it/blog/second-post.html',
  '/it/blog/tag/javascript.html',
  '/it/blog/third-post.html',
  '/it/blog/welcome-to-chiron.html',
  '/it/buttons-showcase.html',
  '/it/custom-template-test.html',
  '/it/dashboard-demo.html',
  '/it/data-island-docs.html',
  '/it/embeds-demo.html',
  '/it/external-scripts-demo.html',
  '/it/forms-demo.html',
  '/it/grid-demo.html',
  '/it/index.html',
  '/it/landing-demo.html',
  '/it/manage-cookies.html',
  '/it/plugins/auth/api-reference.html',
  '/it/plugins/auth/guide.html',
  '/it/plugins/auth/index.html',
  '/it/plugins/cache/api-reference.html',
  '/it/plugins/cache/index.html',
  '/it/plugins/index.html',
  '/it/privacy-policy.html',
  '/it/react-demo.html',
  '/it/shortcodes-showcase.html',
  '/it/showcase.html',
  '/it/slideshow-demo.html',
  '/it/tabs-demo.html',
  '/it/terms-of-service.html',
  '/it/test-data-island.html',
  '/it/test-menu-helper.html',
  '/it/test-no-base.html',
  '/it/test-no-dropdown.html',
  '/it/test-shortcodes.html',
  '/it/toc-depth-test.html',
  '/landing-demo.html',
  '/manage-cookies.html',
  '/plugins/auth/api-reference.html',
  '/plugins/auth/guide.html',
  '/plugins/auth/index.html',
  '/plugins/cache/api-reference.html',
  '/plugins/cache/index.html',
  '/plugins/index.html',
  '/privacy-policy.html',
  '/react-demo.html',
  '/shortcodes-showcase.html',
  '/showcase.html',
  '/slideshow-demo.html',
  '/tabs-demo.html',
  '/terms-of-service.html',
  '/test-data-island.html',
  '/test-menu-helper.html',
  '/test-no-base.html',
  '/test-no-dropdown.html',
  '/test-shortcodes.html',
  '/toc-depth-test.html',
  '/custom.css',
  '/fonts.css',
  '/styles.css'
  
];

/**
 * Font assets - cached with long TTL (immutable)
 */
const FONT_ASSETS = [
  '/assets/fonts/noto-sans/noto-sans-cyrillic-500-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-cyrillic-600-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-cyrillic-700-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-cyrillic-ext-500-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-cyrillic-ext-600-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-cyrillic-ext-700-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-devanagari-500-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-devanagari-600-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-devanagari-700-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-greek-500-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-greek-600-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-greek-700-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-greek-ext-500-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-greek-ext-600-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-greek-ext-700-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-latin-500-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-latin-600-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-latin-700-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-latin-ext-500-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-latin-ext-600-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-latin-ext-700-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-vietnamese-500-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-vietnamese-600-normal.woff2',
  '/assets/fonts/noto-sans/noto-sans-vietnamese-700-normal.woff2'
  
];

/**
 * Static assets - images, scripts
 * Cached on-demand with cache-first strategy
 */
const STATIC_ASSETS = [
  '/assets/bg.svg',
  '/assets/dark.mode.png',
  '/assets/dark.mode.webp',
  '/assets/featured.jpg',
  '/assets/featured.webp',
  '/assets/icons.svg',
  '/assets/images/authors/marco-rossi.svg',
  '/assets/images/authors/sofia-bianchi.svg',
  '/assets/images/blog/docs-building.svg',
  '/assets/images/blog/getting-started.svg',
  '/assets/images/blog/welcome-hero.svg',
  '/assets/logo-black.png',
  '/assets/logo-black.webp',
  '/assets/logo-footer-white.png',
  '/assets/logo-footer-white.webp',
  '/assets/logo-footer.png',
  '/assets/logo-footer.webp',
  '/assets/logo-white.png',
  '/assets/logo-white.webp',
  '/favicon-16.png',
  '/favicon-180.png',
  '/favicon-192.png',
  '/favicon-32.png',
  '/favicon-512.png',
  '/og-image.png',
  '/assets/react-api-explorer.js',
  '/assets/test-data-island.js',
  '/base-minimal.js',
  '/base.js',
  '/custom.js',
  '/search-client.js',
  '/sw.js'
  
];

/**
 * Cache TTL configuration (milliseconds)
 */
const CACHE_TTL = {
  html: 3600000,      // 3600 seconds
  styles: 86400000,  // 86400 seconds
  fonts: 31536000000,    // 31536000 seconds
  images: 604800000,  // 604800 seconds
  scripts: 86400000 // 86400 seconds
};

/**
 * Offline fallback configuration
 */
const OFFLINE_CONFIG = {
  enabled: true,
  fallbackPage: '/offline.html'
};

/**
 * Update notification configuration
 */
const UPDATE_NOTIFICATION = {
  enabled: true,
  auto: false
};

// ============================================================================
// SERVICE WORKER LIFECYCLE
// ============================================================================

/**
 * Install Event - Precache critical assets
 * 
 * This runs when the Service Worker is first installed.
 * Downloads all critical assets (HTML, CSS, fonts) for instant offline access.
 * Uses skipWaiting() to activate immediately without waiting for old SW to close.
 */
self.addEventListener('install', (event) => {
  console.log('[Chiron SW] Installing Service Worker version:', CACHE_VERSION);
  
  event.waitUntil(
    caches.open(CACHE_NAMES.CRITICAL)
      .then((cache) => {
        console.log('[Chiron SW] Precaching critical assets:', CRITICAL_ASSETS.length);
        return cache.addAll(CRITICAL_ASSETS);
      })
      .then(() => {
        console.log('[Chiron SW] Critical assets cached successfully');
        // Skip waiting to activate immediately
        return self.skipWaiting();
      })
      .catch((error) => {
        console.error('[Chiron SW] Failed to cache critical assets:', error);
        throw error;
      })
  );
});

/**
 * Activate Event - Clean up old caches
 * 
 * Runs when Service Worker activates (after install or when new version detected).
 * Deletes old cache versions to free up storage.
 * Claims all clients immediately so new SW takes control without page refresh.
 */
self.addEventListener('activate', (event) => {
  console.log('[Chiron SW] Activating Service Worker version:', CACHE_VERSION);
  
  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        // Find all Chiron caches that don't match current version
        const oldCaches = cacheNames.filter((cacheName) => {
          return cacheName.startsWith('chiron-') && !ALL_CACHES.includes(cacheName);
        });
        
        console.log('[Chiron SW] Deleting old caches:', oldCaches.length);
        
        // Delete all old caches
        return Promise.all(
          oldCaches.map((cacheName) => {
            console.log('[Chiron SW] Deleting cache:', cacheName);
            return caches.delete(cacheName);
          })
        );
      })
      .then(() => {
        console.log('[Chiron SW] Old caches cleaned up');
        // Take control of all pages immediately
        return self.clients.claim();
      })
      .then(() => {
        console.log('[Chiron SW] Service Worker activated and ready');
        
        // Notify clients about update if enabled
        if (UPDATE_NOTIFICATION.enabled) {
          notifyClientsAboutUpdate();
        }
      })
  );
});

/**
 * Fetch Event - Cache-first strategy
 * 
 * Intercepts all network requests.
 * Strategy: Check cache first → return immediately if found → fallback to network
 * 
 * This provides:
 * - Instant page loads (< 50ms from cache)
 * - Offline support (cached content available)
 * - Automatic network fallback (if not in cache)
 */
self.addEventListener('fetch', (event) => {
  const request = event.request;
  
  // Only handle GET requests (no caching for POST/PUT/DELETE)
  if (request.method !== 'GET') {
    return;
  }
  
  // Skip non-HTTP(S) requests (chrome-extension://, etc.)
  if (!request.url.startsWith('http')) {
    return;
  }
  
  event.respondWith(
    handleFetchRequest(request)
  );
});

// ============================================================================
// FETCH HANDLERS
// ============================================================================

/**
 * Handle fetch request with cache-first strategy
 * 
 * @param {Request} request - Fetch request
 * @returns {Promise<Response>} Response from cache or network
 */
async function handleFetchRequest(request) {
  try {
    // 1. Check cache first (INSTANT)
    const cachedResponse = await caches.match(request);
    
    if (cachedResponse) {
      // Cache hit - return immediately
      console.log('[Chiron SW] Cache HIT:', request.url);
      
      // Check if cache is stale and update in background
      updateCacheInBackground(request, cachedResponse);
      
      return cachedResponse;
    }
    
    // 2. Cache miss - fetch from network
    console.log('[Chiron SW] Cache MISS:', request.url);
    return await fetchAndCache(request);
    
  } catch (error) {
    console.error('[Chiron SW] Fetch error:', error);
    
    // 3. Network failed - try offline fallback
    if (OFFLINE_CONFIG.enabled) {
      return await handleOfflineFallback(request);
    }
    
    throw error;
  }
}

/**
 * Fetch from network and cache response
 * 
 * @param {Request} request - Fetch request
 * @returns {Promise<Response>} Network response
 */
async function fetchAndCache(request) {
  const response = await fetch(request);
  
  // Only cache successful responses
  if (response.ok) {
    const cacheName = getCacheNameForRequest(request);
    const cache = await caches.open(cacheName);
    
    // Clone response before caching (can only read once)
    cache.put(request, response.clone());
    
    console.log('[Chiron SW] Cached:', request.url);
  }
  
  return response;
}

/**
 * Update cache in background if stale
 * 
 * @param {Request} request - Original request
 * @param {Response} cachedResponse - Cached response
 */
async function updateCacheInBackground(request, cachedResponse) {
  // Don't update fonts (immutable, long TTL)
  if (request.url.match(/\.(woff2?|ttf|otf|eot)$/)) {
    return;
  }
  
  try {
    // Check cache age
    const cacheDate = new Date(cachedResponse.headers.get('date'));
    const now = new Date();
    const age = now - cacheDate;
    
    // Determine TTL based on content type
    const ttl = getTTLForRequest(request);
    
    // If stale, update in background
    if (age > ttl) {
      console.log('[Chiron SW] Cache stale, updating in background:', request.url);
      
      const response = await fetch(request);
      if (response.ok) {
        const cacheName = getCacheNameForRequest(request);
        const cache = await caches.open(cacheName);
        await cache.put(request, response);
        
        console.log('[Chiron SW] Background update complete:', request.url);
      }
    }
  } catch (error) {
    // Background update failed - not critical, ignore
    console.warn('[Chiron SW] Background update failed:', error);
  }
}

/**
 * Handle offline fallback
 * 
 * @param {Request} request - Original request
 * @returns {Promise<Response>} Offline fallback response
 */
async function handleOfflineFallback(request) {
  // For HTML pages, return offline.html
  if (request.headers.get('accept')?.includes('text/html')) {
    const offlinePage = await caches.match(OFFLINE_CONFIG.fallbackPage);
    if (offlinePage) {
      return offlinePage;
    }
  }
  
  // For other resources, return a generic offline response
  return new Response('Offline - Content not available', {
    status: 503,
    statusText: 'Service Unavailable',
    headers: {
      'Content-Type': 'text/plain'
    }
  });
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Get appropriate cache name for request
 * 
 * @param {Request} request - Fetch request
 * @returns {string} Cache name
 */
function getCacheNameForRequest(request) {
  const url = request.url;
  
  // Fonts → FONTS cache
  if (url.match(/\.(woff2?|ttf|otf|eot)$/)) {
    return CACHE_NAMES.FONTS;
  }
  
  // Images → IMAGES cache
  if (url.match(/\.(png|jpg|jpeg|gif|svg|webp|ico)$/)) {
    return CACHE_NAMES.IMAGES;
  }
  
  // Everything else → STATIC cache
  return CACHE_NAMES.STATIC;
}

/**
 * Get TTL for request based on content type
 * 
 * @param {Request} request - Fetch request
 * @returns {number} TTL in milliseconds
 */
function getTTLForRequest(request) {
  const url = request.url;
  
  if (url.match(/\.html?$/)) return CACHE_TTL.html;
  if (url.match(/\.css$/)) return CACHE_TTL.styles;
  if (url.match(/\.(woff2?|ttf|otf|eot)$/)) return CACHE_TTL.fonts;
  if (url.match(/\.(png|jpg|jpeg|gif|svg|webp|ico)$/)) return CACHE_TTL.images;
  if (url.match(/\.m?js$/)) return CACHE_TTL.scripts;
  
  return CACHE_TTL.html; // Default
}

/**
 * Notify all clients about Service Worker update
 */
function notifyClientsAboutUpdate() {
  self.clients.matchAll().then((clients) => {
    clients.forEach((client) => {
      client.postMessage({
        type: 'SW_UPDATED',
        version: CACHE_VERSION,
        auto: UPDATE_NOTIFICATION.auto
      });
    });
  });
}

// ============================================================================
// MESSAGE HANDLERS
// ============================================================================

/**
 * Handle messages from clients
 */
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    // Client requested immediate activation
    self.skipWaiting();
  }
  
  if (event.data && event.data.type === 'CLEAR_CACHE') {
    // Client requested cache clear (useful for debugging)
    event.waitUntil(
      caches.keys().then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => caches.delete(cacheName))
        );
      })
    );
  }
});

// ============================================================================
// INITIALIZATION
// ============================================================================

console.log('[Chiron SW] Service Worker loaded - Version:', CACHE_VERSION);
console.log('[Chiron SW] Critical assets:', CRITICAL_ASSETS.length);
console.log('[Chiron SW] Font assets:', FONT_ASSETS.length);
console.log('[Chiron SW] Static assets:', STATIC_ASSETS.length);
console.log('[Chiron SW] Offline support:', OFFLINE_CONFIG.enabled);
console.log('[Chiron SW] Update notifications:', UPDATE_NOTIFICATION.enabled);
