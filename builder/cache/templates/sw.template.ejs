/**
 * Chiron PWA Service Worker
 * 
 * Cache-first, update-in-background strategy
 * Provides instant page loads on repeat visits while ensuring content freshness
 * 
 * Generated by Chiron Cache Manager
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API
 */

// ============================================================================
// CACHE CONFIGURATION
// ============================================================================

/**
 * Cache version - changes on every build
 * When this changes, old caches are automatically cleaned up
 */
const CACHE_VERSION = '<%= cacheVersion %>';

/**
 * Cache names with version
 */
const CACHE_NAMES = {
  CRITICAL: `chiron-critical-${CACHE_VERSION}`,
  FONTS: `chiron-fonts-${CACHE_VERSION}`,
  IMAGES: `chiron-images-${CACHE_VERSION}`,
  STATIC: `chiron-static-${CACHE_VERSION}`
};

/**
 * All cache names for cleanup
 */
const ALL_CACHES = Object.values(CACHE_NAMES);

/**
 * Critical assets - precached on install (HTML, CSS, fonts)
 * These provide instant page loads and eliminate FOUC
 */
const CRITICAL_ASSETS = [
  '/',
  <% criticalAssets.forEach(function(asset, index) { %>'/<%- asset %>'<%= index < criticalAssets.length - 1 ? ',' : '' %>
  <% }); %>
];

/**
 * Font assets - cached with long TTL (immutable)
 */
const FONT_ASSETS = [
  <% fontAssets.forEach(function(asset, index) { %>'/<%- asset %>'<%= index < fontAssets.length - 1 ? ',' : '' %>
  <% }); %>
];

/**
 * Static assets - images, scripts
 * Cached on-demand with cache-first strategy
 */
const STATIC_ASSETS = [
  <% staticAssets.forEach(function(asset, index) { %>'/<%- asset %>'<%= index < staticAssets.length - 1 ? ',' : '' %>
  <% }); %>
];

/**
 * Cache TTL configuration (milliseconds)
 */
const CACHE_TTL = {
  html: <%= ttl.html %>,      // <%= ttl.html / 1000 %> seconds
  styles: <%= ttl.styles %>,  // <%= ttl.styles / 1000 %> seconds
  fonts: <%= ttl.fonts %>,    // <%= ttl.fonts / 1000 %> seconds
  images: <%= ttl.images %>,  // <%= ttl.images / 1000 %> seconds
  scripts: <%= ttl.scripts %> // <%= ttl.scripts / 1000 %> seconds
};

/**
 * Offline fallback configuration
 */
const OFFLINE_CONFIG = {
  enabled: <%= offlineEnabled %>,
  fallbackPage: '/offline.html'
};

/**
 * Update notification configuration
 */
const UPDATE_NOTIFICATION = {
  enabled: <%= updateNotificationEnabled %>,
  auto: <%= updateNotificationAuto %>
};

// ============================================================================
// SERVICE WORKER LIFECYCLE
// ============================================================================

/**
 * Install Event - Precache critical assets
 * 
 * This runs when the Service Worker is first installed.
 * Downloads all critical assets (HTML, CSS, fonts) for instant offline access.
 * Uses skipWaiting() to activate immediately without waiting for old SW to close.
 */
self.addEventListener('install', (event) => {
  console.log('[Chiron SW] Installing Service Worker version:', CACHE_VERSION);
  
  event.waitUntil(
    caches.open(CACHE_NAMES.CRITICAL)
      .then((cache) => {
        console.log('[Chiron SW] Precaching critical assets:', CRITICAL_ASSETS.length);
        return cache.addAll(CRITICAL_ASSETS);
      })
      .then(() => {
        console.log('[Chiron SW] Critical assets cached successfully');
        // Skip waiting to activate immediately
        return self.skipWaiting();
      })
      .catch((error) => {
        console.error('[Chiron SW] Failed to cache critical assets:', error);
        throw error;
      })
  );
});

/**
 * Activate Event - Clean up old caches
 * 
 * Runs when Service Worker activates (after install or when new version detected).
 * Deletes old cache versions to free up storage.
 * Claims all clients immediately so new SW takes control without page refresh.
 */
self.addEventListener('activate', (event) => {
  console.log('[Chiron SW] Activating Service Worker version:', CACHE_VERSION);
  
  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        // Find all Chiron caches that don't match current version
        const oldCaches = cacheNames.filter((cacheName) => {
          return cacheName.startsWith('chiron-') && !ALL_CACHES.includes(cacheName);
        });
        
        console.log('[Chiron SW] Deleting old caches:', oldCaches.length);
        
        // Delete all old caches
        return Promise.all(
          oldCaches.map((cacheName) => {
            console.log('[Chiron SW] Deleting cache:', cacheName);
            return caches.delete(cacheName);
          })
        );
      })
      .then(() => {
        console.log('[Chiron SW] Old caches cleaned up');
        // Take control of all pages immediately
        return self.clients.claim();
      })
      .then(() => {
        console.log('[Chiron SW] Service Worker activated and ready');
        
        // Notify clients about update if enabled
        if (UPDATE_NOTIFICATION.enabled) {
          notifyClientsAboutUpdate();
        }
      })
  );
});

/**
 * Fetch Event - Cache-first strategy
 * 
 * Intercepts all network requests.
 * Strategy: Check cache first → return immediately if found → fallback to network
 * 
 * This provides:
 * - Instant page loads (< 50ms from cache)
 * - Offline support (cached content available)
 * - Automatic network fallback (if not in cache)
 */
self.addEventListener('fetch', (event) => {
  const request = event.request;
  
  // Only handle GET requests (no caching for POST/PUT/DELETE)
  if (request.method !== 'GET') {
    return;
  }
  
  // Skip non-HTTP(S) requests (chrome-extension://, etc.)
  if (!request.url.startsWith('http')) {
    return;
  }
  
  event.respondWith(
    handleFetchRequest(request)
  );
});

// ============================================================================
// FETCH HANDLERS
// ============================================================================

/**
 * Handle fetch request with cache-first strategy
 * 
 * @param {Request} request - Fetch request
 * @returns {Promise<Response>} Response from cache or network
 */
async function handleFetchRequest(request) {
  try {
    // 1. Check cache first (INSTANT)
    const cachedResponse = await caches.match(request);
    
    if (cachedResponse) {
      // Cache hit - return immediately
      console.log('[Chiron SW] Cache HIT:', request.url);
      
      // Check if cache is stale and update in background
      updateCacheInBackground(request, cachedResponse);
      
      return cachedResponse;
    }
    
    // 2. Cache miss - fetch from network
    console.log('[Chiron SW] Cache MISS:', request.url);
    return await fetchAndCache(request);
    
  } catch (error) {
    console.error('[Chiron SW] Fetch error:', error);
    
    // 3. Network failed - try offline fallback
    if (OFFLINE_CONFIG.enabled) {
      return await handleOfflineFallback(request);
    }
    
    throw error;
  }
}

/**
 * Fetch from network and cache response
 * 
 * @param {Request} request - Fetch request
 * @returns {Promise<Response>} Network response
 */
async function fetchAndCache(request) {
  const response = await fetch(request);
  
  // Only cache successful responses
  if (response.ok) {
    const cacheName = getCacheNameForRequest(request);
    const cache = await caches.open(cacheName);
    
    // Clone response before caching (can only read once)
    cache.put(request, response.clone());
    
    console.log('[Chiron SW] Cached:', request.url);
  }
  
  return response;
}

/**
 * Update cache in background if stale
 * 
 * @param {Request} request - Original request
 * @param {Response} cachedResponse - Cached response
 */
async function updateCacheInBackground(request, cachedResponse) {
  // Don't update fonts (immutable, long TTL)
  if (request.url.match(/\.(woff2?|ttf|otf|eot)$/)) {
    return;
  }
  
  try {
    // Check cache age
    const cacheDate = new Date(cachedResponse.headers.get('date'));
    const now = new Date();
    const age = now - cacheDate;
    
    // Determine TTL based on content type
    const ttl = getTTLForRequest(request);
    
    // If stale, update in background
    if (age > ttl) {
      console.log('[Chiron SW] Cache stale, updating in background:', request.url);
      
      const response = await fetch(request);
      if (response.ok) {
        const cacheName = getCacheNameForRequest(request);
        const cache = await caches.open(cacheName);
        await cache.put(request, response);
        
        console.log('[Chiron SW] Background update complete:', request.url);
      }
    }
  } catch (error) {
    // Background update failed - not critical, ignore
    console.warn('[Chiron SW] Background update failed:', error);
  }
}

/**
 * Handle offline fallback
 * 
 * @param {Request} request - Original request
 * @returns {Promise<Response>} Offline fallback response
 */
async function handleOfflineFallback(request) {
  // For HTML pages, return offline.html
  if (request.headers.get('accept')?.includes('text/html')) {
    const offlinePage = await caches.match(OFFLINE_CONFIG.fallbackPage);
    if (offlinePage) {
      return offlinePage;
    }
  }
  
  // For other resources, return a generic offline response
  return new Response('Offline - Content not available', {
    status: 503,
    statusText: 'Service Unavailable',
    headers: {
      'Content-Type': 'text/plain'
    }
  });
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Get appropriate cache name for request
 * 
 * @param {Request} request - Fetch request
 * @returns {string} Cache name
 */
function getCacheNameForRequest(request) {
  const url = request.url;
  
  // Fonts → FONTS cache
  if (url.match(/\.(woff2?|ttf|otf|eot)$/)) {
    return CACHE_NAMES.FONTS;
  }
  
  // Images → IMAGES cache
  if (url.match(/\.(png|jpg|jpeg|gif|svg|webp|ico)$/)) {
    return CACHE_NAMES.IMAGES;
  }
  
  // Everything else → STATIC cache
  return CACHE_NAMES.STATIC;
}

/**
 * Get TTL for request based on content type
 * 
 * @param {Request} request - Fetch request
 * @returns {number} TTL in milliseconds
 */
function getTTLForRequest(request) {
  const url = request.url;
  
  if (url.match(/\.html?$/)) return CACHE_TTL.html;
  if (url.match(/\.css$/)) return CACHE_TTL.styles;
  if (url.match(/\.(woff2?|ttf|otf|eot)$/)) return CACHE_TTL.fonts;
  if (url.match(/\.(png|jpg|jpeg|gif|svg|webp|ico)$/)) return CACHE_TTL.images;
  if (url.match(/\.m?js$/)) return CACHE_TTL.scripts;
  
  return CACHE_TTL.html; // Default
}

/**
 * Notify all clients about Service Worker update
 */
function notifyClientsAboutUpdate() {
  self.clients.matchAll().then((clients) => {
    clients.forEach((client) => {
      client.postMessage({
        type: 'SW_UPDATED',
        version: CACHE_VERSION,
        auto: UPDATE_NOTIFICATION.auto
      });
    });
  });
}

// ============================================================================
// MESSAGE HANDLERS
// ============================================================================

/**
 * Handle messages from clients
 */
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    // Client requested immediate activation
    self.skipWaiting();
  }
  
  if (event.data && event.data.type === 'CLEAR_CACHE') {
    // Client requested cache clear (useful for debugging)
    event.waitUntil(
      caches.keys().then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => caches.delete(cacheName))
        );
      })
    );
  }
});

// ============================================================================
// INITIALIZATION
// ============================================================================

console.log('[Chiron SW] Service Worker loaded - Version:', CACHE_VERSION);
console.log('[Chiron SW] Critical assets:', CRITICAL_ASSETS.length);
console.log('[Chiron SW] Font assets:', FONT_ASSETS.length);
console.log('[Chiron SW] Static assets:', STATIC_ASSETS.length);
console.log('[Chiron SW] Offline support:', OFFLINE_CONFIG.enabled);
console.log('[Chiron SW] Update notifications:', UPDATE_NOTIFICATION.enabled);
